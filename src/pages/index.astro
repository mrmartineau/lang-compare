---
import CompareLayout from '../layouts/CompareLayout.astro'
import IntroCard from '../components/IntroCard.astro'
import FeatureCard from '../components/FeatureCard.astro'
import { getCollection, render } from 'astro:content'

// Category display config
const categories: Record<string, { label: string; color: string }> = {
  web: { label: 'Web', color: '#3b82f6' },
  systems: { label: 'Systems', color: '#ef4444' },
  app: { label: 'App Development', color: '#8b5cf6' },
  scripting: { label: 'Scripting & Data', color: '#10b981' },
}

// Get all language meta entries, sorted by category then order
const languageMetas = (await getCollection('languages')).sort((a, b) => {
  const catOrder = ['web', 'systems', 'app', 'scripting']
  const catA = catOrder.indexOf(a.data.category)
  const catB = catOrder.indexOf(b.data.category)
  if (catA !== catB) return catA - catB
  return (a.data.order ?? 0) - (b.data.order ?? 0)
})

// Get all feature entries
const allFeatures = await getCollection('features')

// Derive unique feature keys + titles from all languages.
// Sort by a learning-first flow, then fallback to frontmatter order for unknown sections.
const featureMap = new Map<string, { title: string; order: number }>()
for (const f of allFeatures) {
  const key = f.id.split('/').pop()!
  const existing = featureMap.get(key)
  if (!existing || f.data.order < existing.order) {
    featureMap.set(key, { title: f.data.title, order: f.data.order })
  }
}

const learningFlowOrder = [
  'installation',
  'project-scaffolding',
  'package-management',
  'tooling',
  'build-compile',
  'libraries-frameworks',
  'testing',
  'debugging',
  'variables',
  'types',
  'data-structures',
  'functions',
  'conditionals',
  'loops',
  'generics',
  'inheritance',
  'functional-patterns',
  'concurrency',
  'modules-imports',
  'error-handling',
  'memory-management',
  'profiling',
  'interop',
  'packaging-distribution',
]

const learningFlowIndex = new Map(
  learningFlowOrder.map((key, index) => [key, index]),
)

const featureOrder = [...featureMap.entries()]
  .sort(([keyA, a], [keyB, b]) => {
    const idxA = learningFlowIndex.get(keyA)
    const idxB = learningFlowIndex.get(keyB)
    const aKnown = idxA !== undefined
    const bKnown = idxB !== undefined
    if (aKnown && bKnown) return idxA - idxB
    if (aKnown) return -1
    if (bKnown) return 1
    if (a.order !== b.order) return a.order - b.order
    return a.title.localeCompare(b.title)
  })
  .map(([key, { title }]) => ({ key, title }))

// Pre-render all features grouped by language slug and feature key
type RenderedFeature = { title: string; Content: any }
const renderedByLangAndKey: Record<string, Record<string, RenderedFeature>> = {}

for (const meta of languageMetas) {
  const slug = meta.data.slug
  renderedByLangAndKey[slug] = {}
  const langFeatures = allFeatures.filter((f) => f.id.startsWith(slug + '/'))

  for (const feature of langFeatures) {
    const key = feature.id.split('/').pop()!
    const { Content } = await render(feature)
    renderedByLangAndKey[slug][key] = { title: feature.data.title, Content }
  }
}

// Language info for the picker (with category)
const languageList = languageMetas.map((m) => ({
  slug: m.data.slug,
  name: m.data.name,
  category: m.data.category,
}))

// Section info for the nav
const sectionList = featureOrder.map((f) => ({
  key: f.key,
  title: f.title,
}))

const colCount = languageMetas.length
---

<CompareLayout
  languages={languageList}
  categories={categories}
  sections={sectionList}
>
  {/* Sticky language name headers â€” outside the grid so they stick properly */}
  <div
    class="lang-headers"
    style={`grid-template-columns: repeat(${colCount}, minmax(350px, 1fr));`}
  >
    {
      languageMetas.map((meta) => {
        const cat = categories[meta.data.category]
        return (
          <div
            class="bg-[var(--color-surface-alt)] border-b border-[var(--color-border)] px-4 py-2"
            data-lang={meta.data.slug}
            data-category={meta.data.category}
          >
            <div class="flex items-center gap-2">
              <span
                class="inline-block w-2.5 h-2.5 shrink-0"
                style={`background-color: ${cat.color};`}
              />
              <h2 class="text-base font-bold">{meta.data.name}</h2>
              <span class="text-xs text-[var(--color-text-muted)]">
                {cat.label}
              </span>
            </div>
          </div>
        )
      })
    }
  </div>

  <div
    class="comparison-grid"
    style={`grid-template-columns: repeat(${colCount}, minmax(350px, 1fr));`}
  >
    {/* Row: Intro cards */}
    {
      languageMetas.map((meta, i) => (
        <div data-lang={meta.data.slug}>
          {i === 0 && <div id="section-intro" class="section-anchor" />}
          <IntroCard
            name={meta.data.name}
            description={meta.data.description}
            links={meta.data.links}
            slug={meta.data.slug}
          />
        </div>
      ))
    }

    {/* Rows: Feature cards */}
    {
      featureOrder.map(({ key, title }) =>
        languageMetas.map((meta, i) => {
          const slug = meta.data.slug
          const feature = renderedByLangAndKey[slug]?.[key]
          return (
            <div data-lang={slug}>
              {i === 0 && <div id={`section-${key}`} class="section-anchor" />}
              {feature ? (
                <FeatureCard title={feature.title}>
                  <feature.Content />
                </FeatureCard>
              ) : (
                <FeatureCard title={title}>
                  <p class="text-sm text-[var(--color-text-muted)]">
                    Content for this section has not been added for{' '}
                    <span class="font-semibold text-[var(--color-text)]">
                      {meta.data.name}
                    </span>{' '}
                    yet.
                  </p>
                </FeatureCard>
              )}
            </div>
          )
        }),
      )
    }
  </div>
</CompareLayout>

<style>
  .lang-headers {
    display: grid;
    gap: 1px;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .comparison-grid {
    display: grid;
    gap: 1px;
  }

  .section-anchor {
    scroll-margin-top: var(--header-height);
  }
</style>
